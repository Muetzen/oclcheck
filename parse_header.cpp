#include "parse_header.h"
#include <iostream>
#include <sstream>
#include <string.h>

ParseHeader::ParseHeader (void)
{
}


std::string
ParseHeader::parse (const std::string & filename)
{
    mLine = 1;
    mLastComment.clear ();

    mFile.open (filename);  
    if (mFile.good () == false)
    {
        return std::string ("Could not open file '") + filename + "'.";
    }

    std::string ret = parseFile ();

    mFile.close ();

    return ret;
}


std::string
ParseHeader::printErrorStringMethod (void)
{
    std::string ret;

    std::cout << "// This file is automatically generated, do not edit.\n\n";

    std::cout << "static const char * errorString (cl_int code)\n";
    std::cout << "{\n";

    // TODO: Use thread local storage
    std::cout << "\tstatic char unknownCode [32];\n";

    std::cout << "\tswitch (code)\n";
    std::cout << "\t{\n";

    for (size_t i = 0; i < mClErrorCodes.size (); ++i)
    {
        std::cout << "\tcase " << mClErrorCodes [i] << ": return \"" << mClErrorCodes [i] << "\";\n";
    }
    std::cout << "\t}\n";

    std::cout << "\tsnprintf (unknownCode, sizeof (unknownCode), \"UNKNOWN ERROR %d\", code);\n";
    std::cout << "\treturn unknownCode;\n";
    std::cout << "}\n";

    return ret;
}

struct
{
    const char * mType;
    bool        mIsBitfield = false;
}
gOpenClTypes [] =
{
    { "cl_platform_info" },
    { "cl_device_info" },
    { "cl_device_mem_cache_type" },
    { "cl_device_local_mem_type" },
    { "cl_context_info" },
    { "cl_context_properties" },
    { "cl_device_partition_property" },
    { "cl_command_queue_info" },
    { "cl_channel_order" },
    { "cl_channel_type" },
    { "cl_mem_object_type" },
    { "cl_mem_info" },
    { "cl_image_info" },
    { "cl_pipe_info" },
    { "cl_addressing_mode" },
    { "cl_filter_mode" },
    { "cl_sampler_info" },
    { "cl_program_info" },
    { "cl_program_build_info" },
    { "cl_kernel_info" },
    { "cl_kernel_arg_info" },
    { "cl_kernel_arg_address_qualifier" },
    { "cl_kernel_arg_access_qualifier" },
    { "cl_kernel_work_group_info" },
    { "cl_kernel_sub_group_info" },
    { "cl_kernel_exec_info" },
    { "cl_event_info" },
    { "cl_command_type" },
    { "cl_buffer_create_type" },
    { "cl_profiling_info" },
    { "cl_khronos_vendor_id" },
    // bitfields
    { "cl_device_type", true },
    { "cl_device_fp_config", true },
    { "cl_device_exec_capabilities", true },
    { "cl_command_queue_properties", true },
    // TODO: { "cl_mem_flags", true },      // same as cl_svm_mem_flags
    { "cl_mem_migration_flags", true },
    { "cl_map_flags", true }
};

std::string
ParseHeader::printClTypeMethods (void)
{
    std::string ret;

    std::cout << "// This file is automatically generated, do not edit.\n\n";

    for (size_t i = 0; i < sizeof (gOpenClTypes) / sizeof (gOpenClTypes [0]); ++i)
    {
        std::cout << "void print_" << gOpenClTypes [i].mType << " (" << gOpenClTypes [i].mType << " val, const char * name)\n";
        std::cout << "{\n";

        std::cout << "\t* gLogStream << name << \" = " << gOpenClTypes [i].mType << " \";\n";

        if (gOpenClTypes [i].mIsBitfield == false)
        {
            // TODO: Use thread local storage
            std::cout << "\tstatic char unknown [64];\n";

            std::cout << "\tswitch (val)\n";
            std::cout << "\t{\n";

            for (size_t j = 0; j < mTypeInfo.size (); ++j)
            {
                if (mTypeInfo [j].mType == gOpenClTypes [i].mType)
                {
                    // CL_DEVICE_QUEUE_PROPERTIES is deprecated, and has the same value as
                    // CL_DEVICE_QUEUE_ON_HOST_PROPERTIES:
                    if (mTypeInfo [j].mDefineName != "CL_DEVICE_QUEUE_PROPERTIES")
                    {
                        std::cout << "\tcase " << mTypeInfo [j].mDefineName << ": * gLogStream << \"(" << mTypeInfo [j].mDefineName << ")\";\n";
                        std::cout << "\t\treturn;\n";
                    }
                }
            }

            std::cout << "\t}\n";

            std::cout << "\tsnprintf (unknown, sizeof (unknown), \"(UNKNOWN 0x%X)\", (unsigned int)(val));\n";
            std::cout << "\t* gLogStream << unknown;\n";
        }
        else
        {
            std::cout << "\tstd::string string_value;\n";
            std::cout << "\tbool        first = true;\n";

            bool    firstDefineFound = false;

            for (size_t j = 0; j < mTypeInfo.size (); ++j)
            {
                if (mTypeInfo [j].mType == gOpenClTypes [i].mType)
                {
                    if (mTypeInfo [j].mDefineName.ends_with ("_ALL") == false)
                    {
                        std::cout << "\tif (val & " << mTypeInfo [j].mDefineName << ")\n";
                        std::cout << "\t{\n";
                        if (firstDefineFound == true)
                        {
                            std::cout << "\t\tif (first == false)\n";
                            std::cout << "\t\t{\n";
                            std::cout << "\t\t\tstring_value += \" | \";\n";
                            std::cout << "\t\t}\n";
                        }
                        std::cout << "\t\tstring_value += \"" << mTypeInfo [j].mDefineName << "\";\n";
                        std::cout << "\t\tfirst = false;\n";
                        std::cout << "\t}\n";
                        firstDefineFound = true;
                    }
                    else
                    {
                        // ..._ALL:
                        std::cout << "\tif (val == " << mTypeInfo [j].mDefineName << ")\n";
                        std::cout << "\t{\n";
                        std::cout << "\t\tstring_value = \"" << mTypeInfo [j].mDefineName << "\";\n";
                        std::cout << "\t\tfirst = false;\n";
                        std::cout << "\t}\n";
                    }
                }
            }

            std::cout << "\tif (string_value.empty ())\n";
            std::cout << "\t{\n";
            std::cout << "\t\tstring_value = \"UNKNOWN\";\n";
            std::cout << "\t}\n";
            std::cout << "\t* gLogStream << \"(\" << string_value << \") (0x\" << std::hex << val << std::dec << \")\";\n";
        }

        std::cout << "}\n";
    }

    return ret;
}

struct
{
    const char * mType;
    const char * mOpenClName;   // clRetain<mOpenClName>, and clRelease<mOpenClName>
}
gOpenClObjects [] =
{
    { "cl_context", "Context" },
    { "cl_command_queue", "CommandQueue" },
    { "cl_mem", "MemObject" },
    { "cl_sampler", "Sampler" },
    { "cl_program", "Program" },
    { "cl_kernel", "Kernel" },
    { "cl_event", "Event" }
};

std::string
ParseHeader::printMethods (void)
{
    std::string ret;

    for (size_t i = 0; i < mMethods.size (); ++i)
    {
        std::cout << "\n\n";
        std::cout << mMethods [i].mReturnType << "\n";
        std::cout << mMethods [i].mName << "\n";

        ret = printMethodParameter (mMethods [i].mParameters);

        std::cout << "\n{\n";
        std::cout << "\tinitialize ();\n";
        // TODO: Error exit

        if (mMethods [i].mParameters.empty () == false)
        {
            if (mMethods [i].mName.starts_with ("clRetain"))
            {
                std::string clname = mMethods [i].mName.substr (strlen ("clRetain"));
                for (size_t j = 0; j < sizeof (gOpenClObjects) / sizeof (gOpenClObjects [0]); ++j)
                {
                    if (clname == gOpenClObjects [j].mOpenClName)
                    {
                        std::cout << "\tretainPointer (g_" << gOpenClObjects [j].mType << "_vector, "
                            << mMethods [i].mParameters [0].mName << ");\n";

                        break;
                    }
                }
            }
            else if (mMethods [i].mName.starts_with ("clRelease"))
            {
                std::string clname = mMethods [i].mName.substr (strlen ("clRelease"));
                for (size_t j = 0; j < sizeof (gOpenClObjects) / sizeof (gOpenClObjects [0]); ++j)
                {
                    if (clname == gOpenClObjects [j].mOpenClName)
                    {
                        std::cout << "\treleasePointer (g_" << gOpenClObjects [j].mType << "_vector, "
                            << mMethods [i].mParameters [0].mName << ");\n";

                        break;
                    }
                }
            }
        }

        std::cout << "\t*gLogStream << \"OCL> " << mMethods [i].mName << " (\\n\";\n";
        for (size_t j = 0; j < mMethods [i].mParameters.size (); ++j)
        {
            // Special case for program source
            if (mMethods [i].mName == "clCreateProgramWithSource" &&
                mMethods [i].mParameters [j].mName == "strings")
            {
                std::cout << "\tprintOpenClProgramSource (count, strings, lengths);\n";
                continue;
            }

            std::cout << "\t*gLogStream << \"OCL>\\t\";\n";

            std::string printMethod = "printValue";

            for (size_t k = 0; k < sizeof (gOpenClTypes) / sizeof (gOpenClTypes [0]); ++k)
            {
                if (mMethods [i].mParameters [j].mTypePrefix == gOpenClTypes [k].mType)
                {
                    printMethod = "print_";
                    printMethod += gOpenClTypes [k].mType;
                    break;
                }
            }

            std::cout << "\t" << printMethod  << " ("
                << mMethods [i].mParameters [j].mName
                    << ", \"" << mMethods [i].mParameters [j].mName << "\");\n";

            if (j < mMethods [i].mParameters.size () - 1)
            {
                std::cout << "\t*gLogStream << \",\\n\";\n";
            }
            else
            {
                std::cout << "\t*gLogStream << \"\\n\";\n";
            }
        }

        if (has_errcode_ret (mMethods [i].mParameters))
        {
            std::cout << "\tcl_int  internal_error_code;\n";
            std::cout << "\tif (errcode_ret == nullptr)\n";
            std::cout << "\t{\n";
            std::cout << "\t\terrcode_ret = &internal_error_code;\n";
            std::cout << "\t}\n";
        }

        if (mMethods [i].mReturnType == "cl_int")
        {
            std::cout << "\t*gLogStream << \"OCL> ) = \";\n";
        }
        else
        {
            std::cout << "\t*gLogStream << \"OCL> )\\n\";\n";
        }

        std::cout << "\t" << mMethods [i].mReturnType << "(* origMethod)\n";
        printMethodParameter (mMethods [i].mParameters);
        std::cout << "\t= nullptr;\n";

        // TODO: This does not work everywhere
//      std::cout << "\tdecltype (& " << mMethods [i].mName << ") origMethod = nullptr;\n";

        // TODO: make origMethod static and fetch the method only once
        std::cout << "\torigMethod = reinterpret_cast <decltype (origMethod)> (dlsym (RTLD_NEXT, \""
            << mMethods [i].mName << "\"));\n";

        // TODO: check for nullptr before calling origMethod
        if (mMethods [i].mReturnType != "void")
        {
            std::cout << "\t" << mMethods [i].mReturnType << " returnValue;\n";

            std::cout << "\treturnValue = ";
        }
        else
        {
            std::cout << "\t";
        }

        std::cout << "origMethod (\n";
        for (size_t j = 0; j < mMethods [i].mParameters.size (); ++j)
        {
            std::cout << "\t\t" << mMethods [i].mParameters [j].mName;
            if (j < mMethods [i].mParameters.size () - 1)
            {
                std::cout << ",";
            }
            std::cout << "\n";
        }
        std::cout << "\t);\n";

        // These methods return an cl-error code
        if (mMethods [i].mReturnType == "cl_int")
        {
            std::cout << "\t*gLogStream << errorString (returnValue) << \"\\n\";\n";
        }

// TODO: clCreateSubDevices
        if (mMethods [i].mReturnType != "void" &&
            mMethods [i].mReturnType != "cl_int")
        {
            for (size_t j = 0; j < sizeof (gOpenClObjects) / sizeof (gOpenClObjects [0]); ++j)
            {
                if (mMethods [i].mReturnType == gOpenClObjects [j].mType)
                {
                    std::cout << "\tif ( * errcode_ret == CL_SUCCESS)\n";
                    std::cout << "\t{\n";
                    std::cout << "\t\tcreatePointer (g_" << gOpenClObjects [j].mType << "_vector, returnValue);\n";
                    std::cout << "\t}\n";

                    break;
                }
            }
        }

        if (has_errcode_ret (mMethods [i].mParameters))
        {
            std::cout << "\t*gLogStream << \"OCL> +- errcode_ret = \" << errorString ( * errcode_ret) << \"\\n\";\n";
        }

        if (mMethods [i].mReturnType != "void")
        {
            std::cout << "\treturn returnValue;\n";
        }

        std::cout << "}\n";
    }

    return ret;
}


std::string
ParseHeader::printMethodParameter (
        const std::vector <struct parameter> & pl,
        const std::string & indent)
{
    std::string ret;

    std::cout << indent << "(\n";
    for (size_t j = 0; j < pl.size (); ++j)
    {
        std::cout << indent << "\t" << pl [j].mTypePrefix << " ";
        std::cout << pl [j].mName << " ";

        std::cout << pl [j].mTypeSuffix;
        if (pl [j].mParameterList.empty () == false)
        {
            printMethodParameter (pl [j].mParameterList, indent + "\t");
        }
        if (j < pl.size () - 1)
        {
            std::cout << ",";
        }
        std::cout << "\n";
    }
    std::cout << indent << ")";

    return ret;
}


bool
ParseHeader::has_errcode_ret (const std::vector <struct parameter> & pl)
{
    if (pl.empty ())
    {
        return false;
    }

    return pl [pl.size () - 1].mName == "errcode_ret";
}


std::string
ParseHeader::parseFile (void)
{
    std::string ret;
    while (mFile.eof () == false)
    {
        std::string token;

        ret = readToken (token);
        if ( ! ret.empty ())
        {
            break;
        }

        if (token == "#include")
        {
            token += ' ';
            ret = readIncludeFilename (token);
            if ( ! ret.empty ())
            {
                break;
            }
        }

        if (token == "#define")
        {
            std::string name;

            ret = readToken (name);
            if ( ! ret.empty ())
            {
                break;
            }

            std::string value;
            ret = readDefineValue (value);

            // Skip some things
            if (name.starts_with ("CL_ME_") ||
                name.starts_with ("CL_AVC_ME_"))
            {
                continue;
            }

            // TODO: Search for duplicate numeric values
            std::string searchName;
            if (name.ends_with ("_KHR"))
            {
                searchName = name.substr (0, name.length () - strlen ("_KHR")); 
            }
            else if (name.ends_with ("_INTEL"))
            {
                searchName = name.substr (0, name.length () - strlen ("_INTEL")); 
            }

            if (searchName.empty () == false)
            {
                bool    found = false;
                for (struct openclTypeInfo & ti: mTypeInfo)
                {
                    if (ti.mDefineName == searchName)
                    {
                        found = true;
                        break;
                    }
                }

                if (found == true)
                {
                    continue;
                }
            }

            // TODO: this assumes that there is a /* Error Codes */ comment in front of the error codes.
            // It will not work correctly, if this comment changes, or if there are additional comments between
            // the corresponding defines.
            if (mLastComment == "Error Codes" ||    // cl.h
                mLastComment == "Error codes")      // cl_ext.h
            {
                mClErrorCodes.push_back (name);
            }
            else
            {
                for (size_t i = 0; i < sizeof (gOpenClTypes) / sizeof (gOpenClTypes [0]); ++i)
                {
                    if (mLastComment == gOpenClTypes [i].mType)
                    {
                        struct openclTypeInfo   ti;
                        ti.mType = mLastComment;
                        ti.mDefineName = name;
                        mTypeInfo.push_back (ti);
                        break;
                    }
                }
            }

            continue;
        }

        // #if, #endif, #pragma, ...
        if (token [0] == '#')
        {
            std::string value;
            ret = readDefineValue (value);
            continue;
        }

        if (token == "typedef")
        {
            ret = skipStatement ();
            continue;
        }

        if (token == "extern")
        {
            struct  method  m;

            ret = readToken (token);
            if ( ! ret.empty ())
            {
                break;
            }

            if (token == "\"C\"")
            {
                // skip: extern "C"
                continue;
            }

            if (token == "CL_API_ENTRY")
            {
                ret = readToken (m.mReturnType);
            }

            if (m.mReturnType.starts_with ("CL_API_PREFIX__VERSION_"))
            {
                ret = readToken (m.mReturnType);
            }

            ret = readToken (token);
            while (token != "CL_API_CALL")
            {
                m.mReturnType += ' ';
                m.mReturnType += token;
                ret = readToken (token);
            }

//          std::cerr << "return type: " << m.mReturnType << "\n";

            ret = readToken (m.mName);

//          std::cerr << "method name: " << m.mName << "\n";

            ret = readToken (token);

            if (token == "(")
            {
                ret = parseMethodParameter (m.mParameters);
            }

            mMethods.push_back (m);

            // TODO: check CL_API_SUFFIX
            ret = skipStatement ();
            continue;
        }


        
//      std::cerr << token << "\n";
    }

    return ret;
}

std::string
ParseHeader::readToken (std::string & token, enum handleNl  nl)
{
    char        c = '\0';
    std::string ret;

    token.clear ();
    while (mFile.eof () == false && ret.empty ())
    {
        if (mFile.peek () == '\n' && token.empty () == false)
        {
            break;
        }

        mFile.get (c);

        if (c == '\n')
        {
            ++mLine;

            if (nl == RETURN_NL)
            {
                token += c;
                break;
            }
        }
        else if (c == '\\' && mFile.peek () == '\n')
        {
            mFile.get (c);
            continue;
        }
        else if (isspace (c))
        {
            if (token.empty () == false)
            {
                return ret;
            }
        }
        else if (c == '/')
        {
            if (mFile.peek () == '/')
            {
                ret = skipLine ();
            }
            else if (mFile.peek () == '*')
            {
                ret = skipMultiLineComment ();
            }
            else
            {
                std::stringstream   msg;
                msg << "'/" << (char)(mFile.peek ()) << "' found in line " << mLine << ". '/' does not start a comment.";
                ret = msg.str ();
            }
        }
        else if (isalpha (c) || c == '_')
        {
            token += c;

            c = mFile.peek ();
            while (isalnum (c) || c == '_')
            {
                mFile.get (c);
                token += c;
                c = mFile.peek ();
            }

            break;
        }
        else if (c == '#')
        {
            token += c;

            c = mFile.peek ();
            while (isspace (c))
            {
                mFile.get (c);
                c = mFile.peek ();
            }

            c = mFile.peek ();
            while (isalpha (c))
            {
                mFile.get (c);
                token += c;
                c = mFile.peek ();
            }
            break;
        }
        else if (isdigit (c) ||
                ((c == '-' || c == '+') && isdigit (mFile.peek ())))
        {
            token += c;

            c = mFile.peek ();
            while (isxdigit (c) || c == '.' || tolower (c) == 'x' || tolower (c) == 'o' || c == '-' || c == '+')
            {
                mFile.get (c);
                token += c;
                c = mFile.peek ();
            }

            break;
        }
        else if (c == '"')
        {
            token += c;
            mFile.get (c);
            while (! mFile.eof ())
            {
                if (c == '\n')
                {
                    ++mLine;

                    std::stringstream msg;
                    msg << "Unterminated string in line " << mLine << ".";
                    ret = msg.str ();

                    break;
                }
                else if (c == '"')
                {
                    token += c;
                    break;
                }
                else
                {
                    token += c;
                }
                mFile.get (c);
            }

            break;
        }
        else
        {
            token += c;

            char    n;
            switch (c)
            {
                case '>':
                case '<':
                case '&':
                case '|':
                    n = mFile.peek ();
                    if (n == c)
                    {
                        mFile.get (c);
                        token += c;
                        n = mFile.peek ();
                    }
                    if (n == '=')
                    {
                        mFile.get (c);
                        token += c;
                    }
                    break;

                case '=':
                case '!':
                case '~':
                    n = mFile.peek ();
                    if (n == '=')
                    {
                        mFile.get (c);
                        token += c;
                    }
                    break;
            }
            break;
        }
    }
    return ret;
}

std::string
ParseHeader::readIncludeFilename (std::string & token)
{
    char        c;
    std::string ret;

    mFile.get (c);
    while (isspace (c))
    {
        if (c == '\n')
        {
            std::stringstream msg;
            msg << "#include filename expected in line " << mLine << ".";
            ret = msg.str ();

            ++mLine;

            return ret;
        }
        mFile.get (c);
    }

    char lastChar = 0;

    if (c == '"')
    {
        lastChar = '"';
    }
    else if (c == '<')
    {
        lastChar = '>';
    }
    else
    {
        std::stringstream msg;
        msg << "#include filename expected in line " << mLine << ".";
        ret = msg.str ();

        return ret;
    }

    token += c;
        
    mFile.get (c);
    while (c != lastChar)
    {
        if (c == '\n')
        {
            std::stringstream msg;
            msg << "#include filename expected in line " << mLine << ".";
            ret = msg.str ();

            ++mLine;

            return ret;
        }

        token += c;
        mFile.get (c);
    }

    token += c;

    return ret;
}

std::string
ParseHeader::readDefineValue (std::string & token)
{
    std::string ret;

    token.clear ();
    while (true)
    {
        std::string t;

        ret = readToken (t, RETURN_NL);
        if (ret.empty () == false || t == "\n")
        {
            break;
        }

        if (token.empty () == false)
        {
            token += ' ';
        }
        token += t;
    }

    return ret;
}

std::string
ParseHeader::skipLine (void)
{
    std::string ret;
    while (mFile.eof () == false)
    {
        char    c;

        mFile.get (c);

        if (c == '\n')
        {
            ++mLine;
            return ret;
        }
    }
    return ret;
}

// Skip a comment. Note: The first '/' character is already read.
std::string
ParseHeader::skipMultiLineComment (void)
{
    char c;

    // read '*'
    mFile.get (c);

    std::string newComment;

    while (mFile.eof () == false)
    {
        mFile.get (c);

        if (c == '\n')
        {
            ++mLine;
        }
        else if (c == '*' && mFile.peek () == '/')
        {
            // read '/'
            mFile.get (c);

            while (isspace (newComment [0]) || newComment [0] == '*')
            {
                newComment.erase (0, 1);
            }

            while (newComment.empty () == false &&
                (isspace (newComment [newComment.length () - 1]) || newComment [newComment.length () - 1] == '*'))
            {
                newComment.erase (newComment.length () - 1);
            }

            if (newComment.ends_with (" - bitfield"))
            {
                newComment.erase (newComment.length () - strlen (" - bitfield"));
            }

            if (newComment == "Error Codes" ||      // cl.h
                newComment == "Error codes" ||      // cl_ext.h
                strncmp (newComment.c_str (), "cl_", 3) == 0)
            {
                mLastComment = newComment;
            }
            return std::string ();
        }

        newComment += c;
    }

    return "Expected end of multi line comment before end of file.";
}

std::string
ParseHeader::skipStatement (void)
{
    std::string ret;
    std::string token;

    int scope = 0;
    do
    {
        ret = readToken (token);
        if (token == "{")
        {
            ++scope;
        }
        else if (token == "}")
        {
            --scope;
        }
    }
    while (ret.empty () && (scope != 0 || token != ";"));

    return ret;
}

std::string
ParseHeader::parseMethodParameter (std::vector <struct parameter> & parameterList)
{
    std::string ret;
    std::string token;

    while (! mFile.eof () && token != ")")
    {
        struct  parameter   p;

        // Empty parameter list
        ret = readToken (token);
        if (token == ")")
        {
            break;
        }

        // Parameter is (void)
        p.mTypePrefix = token;
        ret = readToken (p.mName);
        if (p.mTypePrefix == "void" && p.mName == ")")
        {
            break;
        }

        // callback parameter
        if (p.mName == "(")
        {
            p.mTypePrefix += ' ';
            p.mTypePrefix += p.mName;

            ret = readToken (p.mName);

            ret = readToken (token);

            while (token != ")")
            {
                p.mTypePrefix += ' ';
                p.mTypePrefix += p.mName;

                p.mName = token;
                ret = readToken (token);
            }

            p.mTypeSuffix = token;

            // This should be "(":
            ret = readToken (token);

            p.mIsCallback = true;
            ret = parseMethodParameter (p.mParameterList);

            // This should be ',' or ')':
            ret = readToken (token);

            parameterList.push_back (p);

//          std::cerr << "Parameter type: " << p.mTypePrefix
//              << ", name: " << p.mName
//              << ", suffix: " << p.mTypeSuffix
//              << "\n";


            continue;
        }

        ret = readToken (token);

        while (token != "," && token != ")" && token != "[")
        {
            p.mTypePrefix += ' '; 
            p.mTypePrefix += p.mName; 
            p.mName = token;

            ret = readToken (token);
        }

        if (token == "[")
        {
            p.mTypeSuffix += token;
            ret = readToken (token);

            if (token != "]")
            {
                std::stringstream msg;
                msg << "Expected ']' in line " << mLine << "\n";
                ret = msg.str ();
            }
            else
            {
                p.mTypeSuffix += token;
                ret = readToken (token);
                // token should be ',' or ')'.

                if (token != "," && token != ")")
                {
                    std::stringstream msg;
                    msg << "Expected ',' or ')' in line " << mLine << "\n";
                    ret = msg.str ();
                }
            }
        }

        parameterList.push_back (p);
    }

    return ret;
}

